<data>
    <!-- all utility functions or seperate math functions-->
    <action>
        function get_dist(x1, y1, x2, y2) {
            var dx = x2 - x1; var dy = y2 - y1;
            return Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
        }

        function toCartesian(radius, theta) {
            return {x: radius * Math.cos(theta), y: radius * Math.sin(theta)};
        }

        function toPolar(x, y) {
            return {radius: Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)), theta: Math.atan2(y, x)}
        }

        function roundDigits(number, digits) {
            return (Std.parseInt(Math.pow(10, digits) * Math.abs(number) - 0.5)+1) / Math.pow(10, digits) * sign(number);
        }

        // iterator to array
        function toArray(i) {
            var r = [];
            for (v in i) {
                r.push(v);
            }
            return r;
        }

        function minArray(a) {
            if (a == null || a == []) return null;
            var min = a[0] != null ? Std.parseFloat(a[0]) : Std.parseFloat(a.next());
            for (v in a) {
                var asint = Std.parseFloat(v); // this took me 30 minutes to realise this is the issue i hate this
                if (asint &lt; min) {
                    min = asint;
                }
            }
            return min; 
        }

        function pointObj(x, y) {
            return {getCenterX: function() {return x;}, getCenterY: function() {return y;}};
        }
        
        function setupListener(listenerid, f, ?globalname, ?priority) {
            globalname = globalname == null ? "crea_" + listenerid : globalname;
            priority = priority == null ? 9999 : priority;
            
            removeListener(listenerid, globalname);
            setGlobal(globalname, f);
            getContainer().stage.addEventListener(listenerid, getGlobal(globalname), false, 9999);
        }
        
        // i dont really need this one but it still feels convenient so eh why not
        function removeListener(listenerid, ?globalname) {
            globalname = globalname == null ? "crea_" + listenerid : globalname;
            var listener = getGlobal(globalname);
            if (listener != null) getContainer().stage.removeEventListener(listenerid, listener);
        }

        function prepGlobal(g, defaultval) {
            if (getGlobal(g) == null) {
                setGlobal(g, defaultval);
            }
        }

        function nearestObjs(n, origin, objs) {
            if (origin.yTile == null && origin.yPos == null) return;
            var cy = origin.yTile == null ? origin.yPos : origin.yTile;
            var dists = new StringMap();
            for (o in objs) {
                var o_y = o.yTile == null ? o.yPos : o.yTile;
                dists.set(get_dist(o.xPos, o_y, origin.xPos, cy), o);
            }

            var final = [];
            for (i in 0 ... n) {
                var k = minArray(dists.keys());
                //trace(k + ": " + dists.get(k));
                final.push(dists.get(k));
                dists.remove(k);
            }
            return final;
        }

        // modified version of getXDistance from the js file
        function getYDistance(o, b, dy) {
            if(dy == null) {
                dy = 1;
            }
            var scaleY = dy;
            if(o.renderer != null) {
                scaleY *= o.renderer.get_scaleY();
            }
            var top = b.get_top();
            var bottom = b.get_bottom();
            var e = o._getBounds(Object.rectangle);
            var loop = o.area.getLoop();
            if(loop &gt; 0) {
                loop *= Tile.SIZE;
                if(top &gt; e.top() + loop * 0.5) {
                    top -= loop;
                    bottom -= loop;
                } else if(top &lt; e.get_top() - loop * 0.5) {
                    top += loop;
                    bottom += loop;
                }
            }
            return Math.max(0,scaleY &lt; 0 ? top - e.get_bottom() : e.get_top() - bottom);
        }
    </action>
</data>